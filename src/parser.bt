// SPDX-FileCopyrightText: 2023-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package main

fun parse(text string) File {
	mut p := Parser{}
	p.init(text)
	return p.parse()
}

struct Parser {
mut:
	tokenizer Tokenizer
	tok TokenKind
	lit string
}

fun (mut p Parser) init(text string) {
	p.tokenizer = Tokenizer{}
	p.tokenizer.init(text)
}

fun (mut p Parser) parse() File {
	p.next()

	decls := p.decls()

	return File{
		name = 'builtin'
		decls = decls
	}
}

fun (mut p Parser) decls() []Decl {
	mut decls := []Decl
	for p.tok != .rcur and p.tok != .eof {
		p.skip(.key_declare)
		decls.push(p.decl())
	}
	return decls
}

fun (mut p Parser) decl() Decl {
	p.skip(.key_export)
	match p.tok {
		.key_const {
			return p.const_decl()
		}
		.key_function {
			return p.function_decl()
		}
		.key_interface {
			return p.interface_decl()
		}
		.key_module {
			return p.module_decl()
		}
		.key_var {
			return p.const_decl()
		}
		else {
			p.error("unexpected token ${p.tok}, ${p.tokenizer.lit}")
			exit(1) // FIXME bait: @noreturn for methods
		}
	}
}

fun (mut p Parser) const_decl() Const {
	p.next()
	name := p.check_name()
	p.check(.colon)
	typ := p.parse_type()
	p.check(.semi)
	return Const{
		name = name
		typ = typ
	}
}

fun (mut p Parser) field() Field {
	name := p.check_name()
	p.skip(.question) // TODO handle optional fields
	p.check(.colon)
	typ := p.parse_type()
	return Field{
		name = name
		typ = typ
	}
}

fun (mut p Parser) function_decl() Function {
	p.next()
	name := p.check_name()
	p.check(.lpar)
	mut params := []Field
	for p.tok != .rpar {
		params.push(p.field())
		if p.tok == .comma {
			p.next()
		}
	}
	p.check(.rpar)
	p.check(.colon)
	typ := p.parse_type()
	p.check(.semi)
	return Function{
		name = name
		params = params
		return_type = typ
	}
}

fun (mut p Parser) interface_decl() Interface {
	p.next()
	name := p.check_name()
	p.check(.lcur)
	mut fields := []Field
	for p.tok != .rcur {
		p.skip(.key_readonly) // TODO properly handle modifiers
		fields.push(p.field())
		p.check(.semi)
		// TODO methods
	}
	p.check(.rcur)
	return Interface{
		name = name
		fields = fields
	}
}

fun (mut p Parser) module_decl() Module {
	p.check(.key_module)
	name := p.lit
	p.check(.string)
	p.check(.lcur)
	decls := p.decls()
	p.check(.rcur)
	return Module{
		name = name
		decls = decls
	}
}

fun (mut p Parser) parse_type() Type {
	name := p.check_name()

	if p.tok == .lsqr {
		p.next()
		p.check(.rsqr)
		return ArrayType {
			elem = p.type_from_name(name)
		}
	}

	return p.type_from_name(name)
}

fun (mut p Parser) type_from_name(name string) Primitive {
	mut kind := PrimitiveKind.unknown
	match name {
		'any' { kind = .any }
		'boolean' { kind = .bool }
		'number' { kind = .number }
		"string" { kind = .string }
		else { panic('unknown type ${name}') }
	}
	return Primitive {
		kind = kind
	}
}

fun (mut p Parser) skip(tok TokenKind) {
	if p.tok == tok {
		p.next()
	}
}

fun (mut p Parser) check(tok TokenKind) {
	if p.tok != tok {
		if p.tok == .unknown or p.tok == .name {
			p.error("got ${p.tok} (${p.tokenizer.lit}), expected ${tok}")
		} else {
			p.error("got ${p.tok}, expected ${tok}")
		}
	}
	p.next()
}

fun (mut p Parser) check_name() string {
	name := p.lit
	p.check(.name)
	return name
}

fun (mut p Parser) next() {
	p.tok = p.tokenizer.next()
	p.lit = p.tokenizer.lit
}

@noreturn
fun (p Parser) error(msg string) {
	l := p.tokenizer.get_line()
	eprintln('line ${l}: ${msg}')
	exit(1)
}
