// SPDX-FileCopyrightText: 2023-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package main

fun parse(text string) Module {
	mut p := Parser{}
	p.init(text)
	return p.parse()
}

struct Parser {
mut:
	tokenizer Tokenizer
	tok TokenKind
	lit string
}

fun (mut p Parser) init(text string) {
	p.tokenizer = Tokenizer{}
	p.tokenizer.init(text)
}

fun (mut p Parser) parse() Module {
	p.next()

	p.expect(.key_declare)
	p.expect(.key_module)
	mod_name := p.lit
	p.expect(.string)
	p.expect(.lcur)

	mut decls := []Decl
	for p.tok != .rcur {
		decls.push(p.decl())
	}

	p.expect(.rcur)
	return Module{
		name = mod_name
		decls = decls
	}
}

fun (mut p Parser) decl() Decl {
	p.skip(.key_export)
	match p.tok {
		.key_interface {
			return p.interface_decl()
		}
		else {
			panic("unexpected token ${p.tok}")
			return EmptyDecl{}
		}
	}
}

fun (mut p Parser) interface_decl() Interface {
	p.next()
	name := p.expect_name()
	p.expect(.lcur)
	p.expect(.rcur)
	return Interface{}
}

fun (mut p Parser) skip(tok TokenKind) {
	if p.tok == tok {
		p.next()
	}
}

fun (mut p Parser) expect(tok TokenKind) {
	if p.tok != tok {
		panic("got ${p.tok}, expected ${tok}")
	}
	p.next()
}

fun (mut p Parser) expect_name() string {
	if p.tok != .name {
		panic("got ${p.tok}, expected .name")
	}
	name := p.lit
	p.next()
	return name
}

fun (mut p Parser) next() {
	p.tok = p.tokenizer.next()
	p.lit = p.tokenizer.lit
}
