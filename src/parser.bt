// SPDX-FileCopyrightText: 2023-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package main

fun parse(text string) Module {
	mut p := Parser{}
	p.init(text)
	return p.parse()
}

struct Parser {
mut:
	tokenizer Tokenizer
	tok TokenKind
	lit string
}

fun (mut p Parser) init(text string) {
	p.tokenizer = Tokenizer{}
	p.tokenizer.init(text)
}

fun (mut p Parser) parse() Module {
	p.next()

	p.check(.key_declare)
	p.check(.key_module)
	mod_name := p.lit
	p.check(.string)
	p.check(.lcur)

	mut decls := []Decl
	for p.tok != .rcur {
		decls.push(p.decl())
	}

	p.check(.rcur)
	return Module{
		name = mod_name
		decls = decls
	}
}

fun (mut p Parser) decl() Decl {
	p.skip(.key_export)
	match p.tok {
		.key_const {
			return p.const_decl()
		}
		.key_interface {
			return p.interface_decl()
		}
		else {
			p.error("unexpected token ${p.tok}, ${p.tokenizer.lit}")
			exit(1) // TODO remove once @noreturn is implemented
		}
	}
}

fun (mut p Parser) const_decl() Const {
	p.next()
	name := p.check_name()
	p.check(.colon)
	typ := p.parse_type()
	p.skip(.semi)
	return Const{
		name = name
		typ = typ
	}
}

fun (mut p Parser) interface_decl() Interface {
	p.next()
	name := p.check_name()
	p.check(.lcur)
	mut fields := []Field
	for p.tok != .rcur {
		p.skip(.key_readonly) // TODO properly handle modifiers
		fname := p.check_name()
		p.skip(.question) // TODO handle optional fields
		p.check(.colon)
		typ := p.parse_type()
		p.skip(.semi)
		fields.push(Field{
			name = fname
			typ = typ
		})
		// TODO methods
	}
	p.check(.rcur)
	return Interface{
		name = name
		fields = fields
	}
}

fun (mut p Parser) parse_type() Type {
	name := p.check_name()

	if p.tok == .lsqr {
		p.next()
		p.check(.rsqr)
		return ArrayType {
			elem = p.primitive_from_name(name)
		}
	}

	return p.primitive_from_name(name)
}

fun (mut p Parser) primitive_from_name(name string) Primitive {
	mut kind := PrimitiveKind.unknown
	match name {
		"string" { kind = .string }
		'number' { kind = .number }
		else { panic('unknown type ${name}') }
	}
	return Primitive {
		kind = kind
	}
}

fun (mut p Parser) skip(tok TokenKind) {
	if p.tok == tok {
		p.next()
	}
}

fun (mut p Parser) check(tok TokenKind) {
	if p.tok != tok {
		if p.tok == .unknown or p.tok == .name {
			p.error("got ${p.tok} (${p.tokenizer.lit}), expected ${tok}")
		} else {
			p.error("got ${p.tok}, expected ${tok}")
		}
		exit(1) // TODO remove once @noreturn is implemented
	}
	p.next()
}

fun (mut p Parser) check_name() string {
	name := p.lit
	p.check(.name)
	return name
}

fun (mut p Parser) next() {
	p.tok = p.tokenizer.next()
	p.lit = p.tokenizer.lit
}

fun (p Parser) error(msg string) {
	l := p.tokenizer.get_line()
	eprintln('line ${l}: ${msg}')
	exit(1)
}
