// Copyright (c) 2023-present Lukas Neubert.
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package main

struct TypeSym {
	name string
	is_generic bool
	is_array bool
	elem_idx i32
	is_union bool
	variants []i32
	is_object bool
	variant_names []string
	is_function bool
	params []Field
	ret_idx i32
}

struct Table {
pub mut:
	indexes map[string]i32
	types []TypeSym
}

fun new_table() Table {
	mut t := Table{}
	t.register_builtins()
	return t
}

fun (mut t Table) register_type(name string) i32 {
	idx := t.indexes[name]
	if idx > 0 {
		return idx
	}

	return t.add_simple_type(name, '#JS.${name}')
}

fun (mut t Table) register_generic(name string, gidx i32) i32 {
	nidx := t.register_type(name)
	gen_type := t.types[gidx]
	full_name := '${name}<${gen_type.name}>'

	idx := t.indexes[full_name]
	if idx > 0 {
		return idx
	}

	return t.push_type(full_name, TypeSym{
		name = name
		is_generic = true
		elem_idx = nidx
	})
}

fun (mut t Table) register_array(name string) i32 {
	// Array already exists
	idx := t.indexes['${name}[]']
	if idx > 0 {
		return idx
	}

	elem_idx := t.register_type(name)

	return t.push_type('${name}[]', TypeSym{
		is_array = true
		elem_idx = elem_idx
	})
}

fun (mut t Table) register_union(variants []i32) i32 {
	mut name := 'Union'
	for v in variants {
		name += '_' + t.types[v].name
	}

	idx := t.indexes[name]
	if idx > 0 {
		return idx
	}

	return t.push_type(name, TypeSym{
		is_union = true
		variants = variants
	})
}

fun (mut t Table) register_object(fields []Field) i32 {
	mut name := 'Object'
	mut variants := []i32
	mut variant_names := []string
	for f in fields {
		name += '_' + t.types[f].name
		variants.push(f.typ)
		variant_names.push(f.name)
	}

	idx := t.indexes[name]
	if idx > 0 {
		return idx
	}

	return t.push_type(name, TypeSym{
		is_object = true
		variants = variants
		variant_names = variant_names
	})
}

fun (mut t Table) register_fun(params []Field, ret_idx i32) i32 {
	mut name := 'Function'
	for p in params {
		name += '_' + t.types[p.typ].name
	}
	name += '__' + t.types[ret_idx].name

	idx := t.indexes[name]
	if idx > 0 {
		return idx
	}

	return t.push_type(name, TypeSym{
		is_function = true
		params = params
		ret_idx = ret_idx
	})
}


fun (mut t Table) add_simple_type(name string, bait_name string) i32 {
	return t.push_type(name, TypeSym{
		name = bait_name
	})
}

fun (mut t Table) push_type(name string, sym TypeSym) i32 {
	new_idx := t.types.length
	t.types.push(sym)
	t.indexes[name] = new_idx
	return new_idx
}

const VOID_IDX := 1
const ANY_IDX := 2

fun (mut t Table) register_builtins() {
	t.register_type('_unknown')
	t.register_type('void')
	t.add_simple_type('any', '#JS.Any')
	t.add_simple_type('boolean', '#JS.Boolean')
	t.add_simple_type('number', '#JS.Number')
	t.add_simple_type('string', '#JS.String')
}

fun (t Table) type_str(idx i32) string {
	typ := t.types[idx]

	// TODO proper generics
	if typ.is_generic {
		return t.type_str(ANY_IDX)
	}

	if typ.is_array {
		return '[]' + t.type_str(typ.elem_idx)
	}

	// TODO proper unions
	if typ.is_union {
		return t.type_str(ANY_IDX)
	}

	// TODO proper objects
	if typ.is_object {
		return t.type_str(ANY_IDX)
	}

	// TODO proper functions
	if typ.is_function {
		return t.type_str(ANY_IDX)
	}

	return typ.name
}
