// Copyright (c) 2023-present Lukas Neubert.
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package main

struct TypeSym {
	name string
	is_array bool
	elem_idx i32
}

struct Table {
pub mut:
	indexes map[string]i32
	types []TypeSym
}

fun new_table() Table {
	mut t := Table{}
	t.register_builtins()
	return t
}

fun (mut t Table) register_type(name string) i32 {
	idx := t.indexes[name]
	if idx > 0 {
		return idx
	}

	return t.add_type(name, '#JS.${name}')
}

fun (mut t Table) register_array(name string) i32 {
	// Array already exists
	idx := t.indexes['${name}[]']
	if idx > 0 {
		return idx
	}

	elem_idx := t.register_type(name)

	new_idx := t.types.length
	t.types.push(TypeSym{
		is_array = true
		elem_idx = elem_idx
	})
	t.indexes['${name}[]'] = new_idx
	return new_idx
}

fun (mut t Table) add_type(name string, bait_name string) i32 {
	new_idx := t.types.length
	t.types.push(TypeSym{
		name = bait_name
	})
	t.indexes[name] = new_idx
	return new_idx
}

fun (mut t Table) register_builtins() {
	t.register_type('_unknown')
	t.add_type('any', '#JS.Any')
	t.add_type('boolean', '#JS.Boolean')
	t.add_type('number', '#JS.Number')
	t.add_type('string', '#JS.String')
}

fun (t Table) type_str(idx i32) string {
	typ := t.types[idx]
	if typ.is_array {
		return '[]' + t.type_str(typ.elem_idx)
	}
	return typ.name
}
