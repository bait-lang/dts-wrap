// Copyright (c) 2023-present Lukas Neubert.
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package main

struct TypeSym {
	name string
	is_generic bool
	is_array bool
	elem_idx i32
}

struct Table {
pub mut:
	indexes map[string]i32
	types []TypeSym
}

fun new_table() Table {
	mut t := Table{}
	t.register_builtins()
	return t
}

fun (mut t Table) register_type(name string) i32 {
	idx := t.indexes[name]
	if idx > 0 {
		return idx
	}

	return t.add_simple_type(name, '#JS.${name}')
}

fun (mut t Table) register_generic(name string, gen_name string) i32 {
	nidx := t.register_type(name)
	gidx := t.register_type(gen_name)

	idx := t.indexes['${name}<${gen_name}>']
	if idx > 0 {
		return idx
	}

	return t.push_type('${name}<${gen_name}>', TypeSym{
		name = name
		is_generic = true
		elem_idx = nidx
	})
}

fun (mut t Table) register_array(name string) i32 {
	// Array already exists
	idx := t.indexes['${name}[]']
	if idx > 0 {
		return idx
	}

	elem_idx := t.register_type(name)

	return t.push_type('${name}[]', TypeSym{
		is_array = true
		elem_idx = elem_idx
	})
}

fun (mut t Table) add_simple_type(name string, bait_name string) i32 {
	return t.push_type(name, TypeSym{
		name = bait_name
	})
}

fun (mut t Table) push_type(name string, sym TypeSym) i32 {
	new_idx := t.types.length
	t.types.push(sym)
	t.indexes[name] = new_idx
	return new_idx
}

const VOID_IDX := 1
const ANY_IDX := 2

fun (mut t Table) register_builtins() {
	t.register_type('_unknown')
	t.register_type('void')
	t.add_simple_type('any', '#JS.Any')
	t.add_simple_type('boolean', '#JS.Boolean')
	t.add_simple_type('number', '#JS.Number')
	t.add_simple_type('string', '#JS.String')
}

fun (t Table) type_str(idx i32) string {
	typ := t.types[idx]

	// TODO proper generics
	if typ.is_generic {
		return t.type_str(ANY_IDX)
	}

	if typ.is_array {
		return '[]' + t.type_str(typ.elem_idx)
	}

	return typ.name
}
