// Copyright (c) 2023-present Lukas Neubert.
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package main

struct Gen {
mut:
	table Table
	out string
}

fun generate(ast Package, table Table) string {
	mut g := Gen{
		table = table
	}
	g.writeln('// Code generated by dts-wrap.')
	g.writeln('package ${ast.name}\n')
	g.decls(ast.decls)
	return g.out
}

fun (mut g Gen) decls(decls []Decl) {
	for decl in decls {
		if decl is Class {
			g.class_decl(decl as Class)
		} else if decl is Const {
			g.const_decl(decl as Const)
		} else if decl is Enum {
			g.enum_decl(decl as Enum)
		} else if decl is Interface {
			g.interface_decl(decl as Interface)
		} else {
			eprintln('unsupported decl: ${decl}')
		}
	}
}

fun (mut g Gen) class_decl(node Class) {
	// TODO gen "extends Foo" once supported in Bait
	g.writeln('struct #JS.${node.name} {')
	for field in node.fields {
		g.write('\t')
		g.field(field)
		g.writeln('')
	}
	g.writeln('}')

	for method in node.methods {
		g.write('fun (this #JS.${node.name}) ${method.name}(')
		g.params(method.params)
		g.ret_type(method.ret_type)
	}
}

fun (mut g Gen) const_decl(node Const) {
	g.writeln('const #JS.${node.name} := ${g.typ(node.typ)}')
}

fun (mut g Gen) enum_decl(node Enum) {
	g.writeln('enum #JS.${node.name} {}')
}

fun (mut g Gen) interface_decl(node Interface) {
	// TODO gen "extends Foo" once supported in Bait
	g.writeln('interface #JS.${node.name} {')

	for field in node.fields {
		g.write('\t')
		g.field(field)
		g.writeln('')
	}

	for method in node.methods {
		// TODO how to gen anon methods?
		if method.is_anon {
			continue
		}

		g.write('\t${method.name}(')
		g.params(method.params)
		g.ret_type(method.ret_type)
	}

	g.writeln('}')
}

fun (mut g Gen) field(field Field) {
	g.write(field.name)
	g.write(' ')
	g.write(g.typ(field.typ))
}

fun (mut g Gen) params(params []Field) {
	for i, param in params {
		g.field(param)
		if i < params.length - 1 {
			g.write(', ')
		}
	}
}

fun (mut g Gen) ret_type(typ i32) {
	if typ == VOID_IDX {
		g.writeln(')')
	} else {
		g.writeln(') ${g.typ(typ)}')
	}
}

fun (mut g Gen) typ(typ i32) string {
	return g.table.type_str(typ)
}

fun (mut g Gen) write (s string){
	g.out += s
}

fun (mut g Gen) writeln (s string){
	g.out += s + "\n"
}
