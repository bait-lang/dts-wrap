// Copyright (c) 2023-present Lukas Neubert.
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package main

struct Parser {
	tokens []Token
mut:
	table Table
	tok Token
	next_tok Token
	pos i32
}

fun parse(tokens []Token, table Table) Package {
	mut p := Parser{
		tokens = tokens
		table = table
	}
	p.next()
	p.next()
	return p.pkg_decl()
}

fun (mut p Parser) pkg_decl() Package {
	p.check(.key_declare)
	p.check(.key_module)
	name := p.tok.val
	p.check(.string)

	mut decls := []Decl
	p.check(.lcur)
	for p.tok.kind != .rcur {
		if p.tok.kind == .key_export {
			p.next()
		}
		decls.push(p.decl())
	}
	p.check(.rcur)

	return Package{
		name = name
		decls = decls
	}
}

fun (mut p Parser) decl() Decl {
	match p.tok.kind {
		.key_const {
			return p.const_decl()
		}
		.key_interface {
			return p.interface_decl()
		}
		else {
			eprintln('unexpected token ${p.tok.kind}: ${p.tok.val}')
			exit(1)
		}
	}
}

fun (mut p Parser) const_decl() Const {
	p.next()
	name := p.check_name()
	p.check(.colon)
	typ := p.parse_type()
	return Const{
		name = name
		typ = typ
	}
}

fun (mut p Parser) interface_decl() Interface {
	p.next()
	name := p.check_name()
	p.table.register_type(name)

	mut fields := []Field
	p.check(.lcur)
	for p.tok.kind != .rcur {
		fields.push(p.field())
	}
	p.check(.rcur)

	return Interface{
		name = name
		fields = fields
	}
}

fun (mut p Parser) field() Field {
	if p.tok.kind == .key_readonly {
		p.next()
	}

	name := p.check_name()

	// TODO properly handle optional fields that can be undefined
	if p.tok.kind == .question {
		p.next()
	}

	p.check(.colon)

	// Array types can be readonly
	if p.tok.kind == .key_readonly {
		p.next()
	}

	typ := p.parse_type()
	return Field{
		name = name
		typ = typ
	}
}

fun (mut p Parser) parse_type() i32 {
	name := p.check_name()

	// Arrays
	if p.tok.kind == .lbr {
		p.next()
		p.check(.rbr)
		return p.table.register_array(name)
	}

	// Normal types
	return p.table.register_type(name)
}

fun (mut p Parser) check(exp TokKind) {
	if p.tok.kind != exp {
		eprintln('line ${p.tok.line}: unexpected `${p.tok.kind}`, expecting `${exp}`')
		exit(1)
	}
	p.next()
}

fun (mut p Parser) check_name() string {
	val := p.tok.val
	p.check(.name)
	return val
}

fun (mut p Parser) next() {
	p.tok = p.next_tok
	p.next_tok = p.tokens[p.pos]
	p.pos += 1
}
