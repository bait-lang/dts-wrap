// Copyright (c) 2023-present Lukas Neubert.
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package main

struct Parser {
	tokens []Token
mut:
	table Table
	tok Token
	next_tok Token
	pos i32
}

fun parse(tokens []Token, table Table) Package {
	mut p := Parser{
		tokens = tokens
		table = table
	}
	p.next()
	p.next()
	return p.pkg_decl()
}

fun (mut p Parser) pkg_decl() Package {
	p.check(.key_declare)
	p.check(.key_module)
	name := p.tok.val
	p.check(.string)

	mut decls := []Decl
	p.check(.lcur)
	for p.tok.kind != .rcur {
		p.skip(.key_export)
		decls.push(p.decl())
	}
	p.check(.rcur)

	return Package{
		name = name
		decls = decls
	}
}

fun (mut p Parser) decl() Decl {
	match p.tok.kind {
		.key_const {
			return p.const_decl()
		}
		.key_interface {
			return p.interface_decl()
		}
		else {
			eprintln('unexpected token ${p.tok.kind}: ${p.tok.val}')
			exit(1)
		}
	}
}

fun (mut p Parser) const_decl() Const {
	p.next()
	name := p.check_name()
	p.check(.colon)
	typ := p.parse_type()
	return Const{
		name = name
		typ = typ
	}
}

fun (mut p Parser) interface_decl() Interface {
	p.next()
	name := p.check_name()
	p.table.register_type(name)

	mut fields := []Field
	mut methods := []Method
	p.check(.lcur)
	for p.tok.kind != .rcur {
		p.skip(.key_readonly)
		fname := p.check_name()
		if p.tok.kind == .lpar {
			methods.push(p.method(fname))
		} else {
			fields.push(p.field(fname))
		}
	}
	p.check(.rcur)

	return Interface{
		name = name
		fields = fields
		methods = methods
	}
}

fun (mut p Parser) field(name string) Field {
	// TODO properly handle optional fields that can be undefined
	p.skip(.question)

	p.check(.colon)

	// Array types can be readonly
	p.skip(.key_readonly)

	typ := p.parse_type()
	return Field{
		name = name
		typ = typ
	}
}

fun (mut p Parser) method(name string) Method {
	p.next()
	mut params := []Field
	p.check(.rpar)
	p.check(.colon)

	ret_type := p.parse_type()

	return Method{
		name = name
		params = params
		ret_type = ret_type
	}
}

fun (mut p Parser) parse_type() i32 {
	name := p.check_name()

	// Arrays
	if p.tok.kind == .lbr {
		p.next()
		p.check(.rbr)
		return p.table.register_array(name)
	}

	// Normal types
	return p.table.register_type(name)
}

fun (mut p Parser) skip(kind TokKind) {
	if p.tok.kind == kind {
		p.next()
	}
}

fun (mut p Parser) check(exp TokKind) {
	if p.tok.kind != exp {
		eprintln('line ${p.tok.line}: unexpected `${p.tok.kind}`, expecting `${exp}`')
		exit(1)
	}
	p.next()
}

fun (mut p Parser) check_name() string {
	val := p.tok.val
	p.check(.name)
	return val
}

fun (mut p Parser) next() {
	p.tok = p.next_tok
	p.next_tok = p.tokens[p.pos]
	p.pos += 1
}
