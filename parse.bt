// Copyright (c) 2023-present Lukas Neubert.
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package main

struct Parser {
	tokens []Token
mut:
	table Table
	tok Token
	next_tok Token
	pos i32
}

fun parse(tokens []Token, table Table) Package {
	mut p := Parser{
		tokens = tokens
		table = table
	}
	p.next()
	p.next()
	return p.pkg_decl()
}

fun (mut p Parser) pkg_decl() Package {
	p.check(.key_declare)
	p.check(.key_module)
	name := p.tok.val
	p.check(.string)

	mut decls := []Decl
	p.check(.lcur)
	for p.tok.kind != .rcur {
		decls.push(p.decl())
	}
	p.check(.rcur)

	return Package{
		name = name
		decls = decls
	}
}

fun (mut p Parser) decl() Decl {
	p.skip(.key_export)

	match p.tok.kind {
		.key_class {
			return p.class_decl()
		}
		.key_const {
			return p.const_decl()
		}
		.key_enum {
			return p.enum_decl()
		}
		.key_interface {
			return p.interface_decl()
		}
		.key_type{
			return p.type_alias_decl()
		}
		else {
			eprintln('unexpected token ${p.tok.kind}: ${p.tok.val}')
			exit(1)
		}
	}
}

// TODO share code between Class and Interface
fun (mut p Parser) class_decl() Class {
	p.next()
	name := p.check_name()
	if p.tok.kind == .lt {
		// TODO store this info in Class and use for codegen
		p.generic_type(name)
	} else {
		p.table.register_type(name)
	}

	mut ext_type := VOID_IDX
	if p.tok.kind == .key_extends {
		p.next()
		ext_name := p.check_name()
		ext_type = p.table.register_type(ext_name)
	}

	mut fields := []Field
	mut methods := []Method
	p.check(.lcur)
	for p.tok.kind != .rcur {
		p.skip(.key_private)
		p.skip(.key_readonly)

		// TODO how to hanlde constructors in Bait?
		if p.tok.kind == .key_constructor {
			p.next()
			p.check(.lpar)
			p.params()
			p.check(.rpar)
			continue
		}

		// TODO how to handle static members in Bait?
		if p.tok.kind == .key_static {
			p.next()
			p.skip(.key_readonly)
		}

		fname := p.check_name()
		if p.tok.kind == .lpar {
			methods.push(p.method(fname))
		} else {
			fields.push(p.field(fname))
		}
	}
	p.check(.rcur)

	return Class{
		name = name
		fields = fields
		methods = methods
		ext_type = ext_type
	}
}

fun (mut p Parser) const_decl() Const {
	p.next()
	name := p.check_name()
	p.check(.colon)
	typ := p.parse_type()
	return Const{
		name = name
		typ = typ
	}
}

fun (mut p Parser) enum_decl() Enum {
	p.next()
	name := p.check_name()
	p.table.register_type(name)

	p.check(.lcur)
	for p.tok.kind != .rcur {
		p.check_name()
		if p.tok.kind == .assign {
			p.next()
			p.check(.number)
		}
		if p.tok.kind != .rcur {
			p.check(.comma)
		}
	}
	p.next()

	return Enum{
		name = name
	}
}

fun (mut p Parser) interface_decl() Interface {
	p.next()
	name := p.check_name()
	if p.tok.kind == .lt {
		// TODO store this info in Interface and use for codegen
		p.generic_type(name)
	} else {
		p.table.register_type(name)
	}

	mut ext_type := VOID_IDX
	if p.tok.kind == .key_extends {
		p.next()
		ext_name := p.check_name()
		ext_type = p.table.register_type(ext_name)
	}

	mut fields := []Field
	mut methods := []Method
	p.check(.lcur)
	for p.tok.kind != .rcur {
		// Anon method
		if p.tok.kind == .lpar {
			mut m := p.method('')
			m.is_anon = true
			methods.push(m)
			continue
		}

		p.skip(.key_readonly)
		fname := p.check_name()

		// TODO properly handle optional members that can be undefined
		p.skip(.question)

		if p.tok.kind == .lpar {
			methods.push(p.method(fname))
		} else {
			fields.push(p.field(fname))
		}
	}
	p.check(.rcur)

	return Interface{
		name = name
		fields = fields
		methods = methods
		ext_type = ext_type
	}
}

fun (mut p Parser) field(name string) Field {
	// Required for optional params
	p.skip(.question)

	p.check(.colon)

	typ := p.parse_type()
	return Field{
		name = name
		typ = typ
	}
}

fun (mut p Parser) method(name string) Method {
	p.next()
	params := p.params()
	p.check(.rpar)
	p.check(.colon)

	ret_type := p.parse_type()

	return Method{
		name = name
		params = params
		ret_type = ret_type
	}
}

fun (mut p Parser) params() []Field {
	mut params := []Field
	for p.tok.kind != .rpar {
		p.skip(.ellipsis) // TODO keep this info for Bait once varargs are implemented
		pname := p.check_name()
		params.push(p.field(pname))
		if p.tok.kind != .rpar {
			p.check(.comma)
		}
	}
	return params
}

fun (mut p Parser) type_alias_decl() TypeAlias {
	p.next()
	typ := p.parse_type()
	p.check(.assign)
	child := p.parse_type()

	return TypeAlias{
		name = p.table.types[typ].name
		typ = typ
		child = child
	}
}

fun (mut p Parser) parse_type() i32 {
	typ := p.complex_type()
	if p.tok.kind == .lbr {
		return p.parse_array_type(p.table.types[typ].name)
	}
	return typ
}

fun (mut p Parser) complex_type() i32 {
	if p.tok.kind == .lcur {
		return p.parse_object_type()
	}

	if p.tok.kind == .lpar {
		p.next()
		if p.next_tok.kind == .pipe {
			return p.grouped_type()
		}
		return p.parse_fun_type()
	}

	if p.tok.kind == .lbr {
		return p.tuple_type()
	}

	typ := p.parse_single_type()
	if p.tok.kind != .pipe {
		return typ
	}

	mut variants := [typ]
	for p.tok.kind == .pipe {
		p.next()
		variants.push(p.parse_single_type())
	}

	return p.table.register_union(variants)
}

fun (mut p Parser) grouped_type() i32 {
	typ := p.parse_type()
	p.check(.rpar)
	return typ
}

fun (mut p Parser) parse_single_type() i32 {
	// Readonly arrays
	if p.tok.kind == .key_readonly {
		p.next()
		return p.parse_array_type(p.check_name())

	}

	name := p.check_name()

	// Arrays
	if p.tok.kind == .lbr {
		return p.parse_array_type(name)
	}

	// Generics
	if p.tok.kind == .lt {
		return p.generic_type(name)
	}

	// Normal types
	return p.table.register_type(name)
}

fun (mut p Parser) parse_array_type(name string) i32 {
	p.check(.lbr)
	p.check(.rbr)
	return p.table.register_array(name)
}

fun (mut p Parser) generic_type(name string) i32 {
	p.check(.lt)
	gidx := p.parse_type()

	if p.tok.kind == .key_extends {
		// TODO somehow handle this
		p.next()
		p.skip(.name)
		p.skip(.assign)
		p.skip(.name)
	}

	p.check(.gt)
	return p.table.register_generic(name, gidx)
}

fun (mut p Parser) parse_object_type() i32 {
	p.check(.lcur)
	mut fields := []Field
	for p.tok.kind != .rcur {
		mut has_property_type := false
		if p.tok.kind == .lbr {
			p.next()
			has_property_type = true
		}

		p.skip(.key_readonly)
		fname := p.check_name()

		if has_property_type {
			// TODO how to handle this in Bait?
			p.check(.colon)
			p.parse_type()
			p.check(.rbr)
		}

		fields.push(p.field(fname))
	}
	p.check(.rcur)
	return p.table.register_object(fields)
}

fun (mut p Parser) parse_fun_type() i32 {
	params := p.params()
	p.check(.rpar)
	p.check(.arrow)
	ret_type := p.parse_type()

	return p.table.register_fun(params, ret_type)
}

fun (mut p Parser) tuple_type() i32 {
	p.check(.lbr)
	mut variants := []i32
	for p.tok.kind != .rbr {
		variants.push(p.parse_single_type())
		if p.tok.kind != .rbr {
			p.check(.comma)
		}
	}
	p.next()
	return p.table.register_tuple(variants)
}

fun (mut p Parser) skip(kind TokKind) {
	if p.tok.kind == kind {
		p.next()
	}
}

fun (mut p Parser) check(exp TokKind) {
	if p.tok.kind != exp {
		eprintln('line ${p.tok.line}: unexpected `${p.tok.kind}`, expecting `${exp}`')
		exit(1)
	}
	p.next()
}

fun (mut p Parser) check_name() string {
	val := p.tok.val
	p.check(.name)
	return val
}

fun (mut p Parser) next() {
	p.tok = p.next_tok
	p.next_tok = p.tokens[p.pos]
	p.pos += 1
}
